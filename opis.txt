const sex
vec <struktur> kolejki[3]
ilosc_w_szatni[3]


1. Każdy proces na początku losuje szatnie

2. Synchronizacja kazdy z kazdym SYNC_MESSAGE(rank, clock, sex, szatnia) TAG SYNC_MESSAGE
 W ten sposob wszyscy maja stan szatni
    2a. Wysylamy do wszystkich
    // 2b. ODBIOR - wysylamy zgode APPROVE_MESSAGE(rank)
    2b. czekamy na wszystkie wiadomosci SYNC_MESSAGE na TAGU SYNC_MESSAGE i zapisujemy je do kolejek (3 do każdej szatni)

//odbieranie w main watku
3. sortujemy kolejki po clock

// main watek
4. Sprawdzamy czy czy w kolejce przede mna jest tylko ta sama plec i w szatni jest tez ta plec. 
Sprawdzamy czy IN_SZATNIA + IN_KOLEJKA + 1 <= POJEMNOSC SZATNI

4a. JEZELI TAK:
    WYSYLAMY KOMUNIKAT              // !!! Niewymagane, nie implementujemy 
    
    WCHODZE_DO_SZATNI_MESSAGE
    tag : WHATEVER
    (rank, szatnia)


4b. JEZELI NIE:
    czekamy na WYCHODZE_Z_SZATNI_MESSAGE
    i sprawdzamy warunek (goto 4)


5. sekcja krytyczna
    losowa ilosc czasu


6. wysyłam wiadomosc 

    WYCHODZE Z SZATNI
    tag : GOING_OUT_OF_CHANGING_ROOM_TAG
    (rank, szatnia)

7. sekcja lokalna
    losowa ilosc czasu

8. dolaczanie do kolejki
    //clock = max(clock, ostatni_w_kolejce_zegar) + 1

    clock = ostatni_w_kolejce_zegar + 1

    wysylamy wiadomosc do wszystkich SYNC_MESSAGE(rank, clock, sex, szatnia)
    tag : WHATEVER
    czekamy na wszystkie zgody

    zgoda APPROVE_MESSAGE()    PUSTE
    tag : WHATEVER


drugi watek
odbiera wiadomosci na tagu WHATEVER



PSEUDOKOD V2

check_if_can_get_in(){
    czy w kolejce przed nami jest ta sama plec?
    IF YES{
        czy suma wszystkich w kolejce przede mna + 1 <= MAX_NUM_IN_LOCKER_ROOM
        IF YES{
            RETURN TRUE
        }
    }
    RETURN FALSE
}

receive(){
    while TRUE{
        odbierz wiadomosc
        IF wiadomosc.tag == SYNC_MESSAGE_TAG{
            dodaj osobe do kolejki
            sortuj kolejke
            my_clock = max(my_clock, wiadomosc.clock)
        }
        IF wiadomosc.tag == APPROVE_MESSAGE_TAG{
            approves++
            IF approves == NUM_PROCESSES{
                approves = 0
                udziel zgody czekającemy na potwierdzenia
            }
        }
        IF wiadomosc.tag == GOING_OUT_OF_CHANGING_ROOM_TAG{
            usuń proces z kolejki
            powiadom czekającego na kolejna wiadomosc tego tagu 
        }
    }
}


main(){
    get_my_rank
    locker_room_number = rand() % 3
    sex = rand() % 2
    my_clock = rand() % NUM_PROCESSES

    sync_message = {rank, my_clock, sex, locker_room_number}
    send_to_all_processes(sync_message, SYNC_MESSAGE_TAG)
    
    dodaj siebie do kolejki

    receive_from_all(SYNC_MESSAGE_TAG, SYNC_MESSAGE_SIZE)
    sort_locker_room_queues()

    thread t1(receive) // odbieranie w drugim watku

    while TRUE {
        while(!check_if_can_get_in()){
            czekaj na kolejna wiadomosc GOING_OUT_OF_CHANGING_ROOM
        }
        
        usuń siebie z kolejki
        
        // SEKCJA KRYTYCZNA
        sleep(rand())
        // KONIEC SEKCJI KRYTYCZNEJ

        going_out_of_changing_room_message = {rank, locker_room_number}
        send_to_all_processes(going_out_of_changing_room_message, GOING_OUT_OF_CHANGING_ROOM_TAG)

        // SEKCJA LOKALNA
        sleep(rand())
        // KONIEC SEKCJI LOKALNEJ

        locker_room_number = rand() % 3
        my_clock = max(my_clock, clock_ostatniego_w_kolejce)

        dodaj siebie do kolejki

        sync_message = {rank, my_clock, sex, locker_room_number}
        send_to_all_processes(sync_message, SYNC_MESSAGE_TAG)

        czekaj na potwierdzenia
    }
} 








